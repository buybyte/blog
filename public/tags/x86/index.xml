<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hextra – X86</title>
    <link>http://localhost:1313/tags/x86/</link>
    <description>Recent content in X86 on Hextra</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 08 Jun 2020 08:09:12 +0800</lastBuildDate>
    
	  <atom:link href="http://localhost:1313/tags/x86/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>asm-how-computer-startup</title>
      <link>http://localhost:1313/blog/asm-how-computer-startup/</link>
      <pubDate>Mon, 08 Jun 2020 08:09:12 +0800</pubDate>
      
      <guid>http://localhost:1313/blog/asm-how-computer-startup/</guid>
      <description>
        
        
        &lt;p&gt;&lt;code&gt;x86&lt;/code&gt; 架构计算机是如何启动的？&lt;/p&gt;
&lt;h2&gt;16-bit Processors and Segmentation (1978)&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;16-bit-processors-and-segmentation-1978&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#16-bit-processors-and-segmentation-1978&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;
  &lt;p&gt;The IA-32 architecture family was preceded by &lt;code&gt;16-bit processors&lt;/code&gt;, the 8086 and 8088. The 8086 has &lt;code&gt;16-bit registers&lt;/code&gt; and a &lt;code&gt;16-bit external data bus&lt;/code&gt;, with &lt;code&gt;20-bit addressing giving a 1-MByte address space&lt;/code&gt;. The 8088 is similar to the 8086 except it has an 8-bit external data bus.
The 8086/8088 introduced &lt;code&gt;segmentation&lt;/code&gt; to the IA-32 architecture. With segmentation, a &lt;code&gt;16-bit segment register&lt;/code&gt; contains a pointer to &lt;code&gt;a memory segment of up to 64 KBytes&lt;/code&gt;. Using &lt;code&gt;four&lt;/code&gt; segment registers at a time, 8086/8088 processors are able to address up to 256 KBytes &lt;code&gt;without&lt;/code&gt; switching between segments. The 20-bit addresses that can be formed using a segment register and an additional 16-bit pointer provide a total address range of 1 MByte.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;8086 是整个 intel 系列处理器的老祖宗。所有后续的一系列处理器都兼容 8086。唉，这就是路径依赖啊。这是一个 16-bit 的处理器。寄存器也是 16-bit 的。but 却能寻址 20-bit 的地址空间，也就是 1M 的内存。怎样在 16-bit 的处理器上实现呢？很简单，将 1M 的空间分成多个 64K 的 segment。那怎样用 16-bit 的寄存器表示 20-bit 的地址呢？也很简单，用 2 个 16-bit 的寄存器组合得来的(register1,register2)。那怎样组合的呢？&lt;code&gt;address = register1 &amp;lt;&amp;lt; 4 + register2&lt;/code&gt;。将 register1 &amp;laquo; 4 和 register2 用一个 20-bit 的加法器就能得到内存地址。这种方式就是所谓的 &lt;code&gt;real address mode&lt;/code&gt;。也即是拿到的是真正的内存地址。x86 架构的计算机启动时会先进入 real address mode。&lt;/p&gt;
&lt;h2&gt;计算机启动前置知识&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;计算机启动前置知识&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e8%ae%a1%e7%ae%97%e6%9c%ba%e5%90%af%e5%8a%a8%e5%89%8d%e7%bd%ae%e7%9f%a5%e8%af%86&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;CPU 工作方式是: 从&lt;code&gt;内存&lt;/code&gt;中取指、执行。&lt;/li&gt;
&lt;li&gt;内存是存储数据的地方，给出一个内存地址，可以得到该处的数据。&lt;/li&gt;
&lt;li&gt;CPU 从内存哪里取指令，由 &lt;code&gt;instruction pointer&lt;/code&gt; 这个寄存器的值决定。这个值不断 +1，或者跳转(jump) 到某处。real address mode 下由 CS:IP 组合决定。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;BIOS&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;bios&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#bios&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3&gt;BIOS 是啥&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;bios-是啥&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#bios-%e6%98%af%e5%95%a5&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;BIOS&lt;/code&gt; 是啥呢？一个软件而已。不像我们平时在 PC 上使用如 &lt;code&gt;QQ&lt;/code&gt; 等软件是安装在硬盘上的。BIOS 安装在 ROM 中。这个软件干啥的呢？帮助计算机启动，开机时检测整个机器的硬件。计算机启动需要运行软件，软件运行需要计算机先启动。咳咳，成了先有鸡还是先有蛋了，这怎么行？所以需要 BIOS 这个在硬件上的软件来帮助，破除这种依赖。&lt;/p&gt;
&lt;h3&gt;BIOS 大小&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;bios-大小&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#bios-%e5%a4%a7%e5%b0%8f&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;通过 &lt;code&gt;dmidecode&lt;/code&gt; 这个命令来查看。也就是读取 BIOS 的信息。&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;root@aliyun:~# dmidecode -t bios -q  &lt;span class=&#34;c1&#34;&gt;# 方法一&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;BIOS Information
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        Vendor: SeaBIOS
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        Version: 8c24b4c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        Release Date: 04/01/2014
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        Address: 0xE8000
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        Runtime Size: &lt;span class=&#34;m&#34;&gt;96&lt;/span&gt; kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        ROM Size: &lt;span class=&#34;m&#34;&gt;64&lt;/span&gt; kB --- ROM Size，在此可以看到，BIOS 大小为 64K。
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        Characteristics:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                BIOS characteristics not supported
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                Targeted content distribution is supported
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        BIOS Revision: 0.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;root@aliyun:~# &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; /sys/class/dmi/id/  &lt;span class=&#34;c1&#34;&gt;# 方法二&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;root@aliyun:id# ls
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;bios_date          chassis_serial   modalias        product_serial   sys_vendor
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;bios_vendor        chassis_type     power           product_uuid     uevent
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;bios_version       chassis_vendor   product_family  product_version
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;chassis_asset_tag  chassis_version  product_name    subsystem&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;x86 架构计算机启动流程&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;x86-架构计算机启动流程&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#x86-%e6%9e%b6%e6%9e%84%e8%ae%a1%e7%ae%97%e6%9c%ba%e5%90%af%e5%8a%a8%e6%b5%81%e7%a8%8b&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/stardustman/pictures/raw/main/img/real-address-mode-how-computer-startup.svg&#34; alt=&#34;real address mode 1M 内存布局&#34; loading=&#34;lazy&#34; /&gt; #(real address mode 1M 内存布局)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如上图所示，当按下 &lt;code&gt;power on&lt;/code&gt; 之后，此时的 CPU 处于 real address mode。由硬件负责将 &lt;code&gt;BIOS 64K&lt;/code&gt; 的内容加载到 &lt;code&gt;0xF0000 到 0xFFFFF&lt;/code&gt;(64K 内存)。并将 &lt;code&gt;CS(code segment) 置为 0xF000&lt;/code&gt;，&lt;code&gt;IP(instruction pointer) 置为 0xFFF0&lt;/code&gt;。组合起来的内存地址 &lt;code&gt;PC&lt;/code&gt; 就是 0xFFFF0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此时 CPU 从 &lt;code&gt;PC = 0xFFFF0&lt;/code&gt; 处开始取指、执行。那么从 &lt;code&gt;0xFFFF0 到 0xFFFFF&lt;/code&gt; 只有 16Bytes。空间太小了，能放啥呢？但是可以跳到其他地方去执行啊。不错，这里存放的有一条指令是 &lt;code&gt;jmp far f000:e05b&lt;/code&gt;, 组合起来就是 &lt;code&gt;0xfe05b&lt;/code&gt;。注意这个地址可是在 &lt;code&gt;0xF0000 到 0xFFFFF&lt;/code&gt; 范围之内，也就是这条指令跳转到 &lt;code&gt;BIOS 内部的代码&lt;/code&gt;去执行。从 0xFE05B 到 0xFFFF0 将近 8K 内存，代码不少。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此时 CPU 从 &lt;code&gt;PC = 0xfe05b&lt;/code&gt; 开始取值、执行。具体干啥呢？就是执行所谓的开机自检。检查计算机硬件。同时去找启动扇区，那什么才是启动扇区呢？若 0 盘 0 道 1 扇区最后两个字节分别是 0x55,0xaa，那就是启动区。很像 java class 文件中的魔数，就是标记一下。同时将找到的启动扇区(512Bytes) 复制到内存 &lt;code&gt;0x7C00 到 0x7DFF&lt;/code&gt;(512Bytes) 处。最后会将 &lt;code&gt;CS 置为 0x0000， IP 置为 0x7C00&lt;/code&gt;，组合起来就是 &lt;code&gt;0x7C00&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此时 CPU 从 &lt;code&gt;PC = 0x7C00&lt;/code&gt; 开始取值、执行。具体干啥呢？这就是开发人员可以决定的了。在启动扇区上可以是加载 OS Kernel 的代码，硬盘分区，boot loader 等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;References&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;references&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#references&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;1.&lt;a href=&#34;http://dewkumar.blogspot.com/2012/01/what-is-org-origin-directive-in.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;x86-ORG&lt;/a&gt;
2. &lt;a href=&#34;https://superuser.com/questions/806226/how-to-see-rom-size&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;how-to-see-rom-size&lt;/a&gt;
3. &lt;a href=&#34;http://smilejay.com/2013/02/bios-info-dmidecode/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bios-info-dmidecode&lt;/a&gt;
4. &lt;a href=&#34;https://en.wikipedia.org/wiki/System_Management_BIOS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;system-management-bios&lt;/a&gt;
5. &lt;a href=&#34;http://www.ruanyifeng.com/blog/2013/02/booting.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;计算机是如何启动的？&lt;/a&gt;
6. &lt;a href=&#34;https://en.wikipedia.org/wiki/Master_boot_record&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;多种 MBR 组织方式&lt;/a&gt;
7. &lt;a href=&#34;https://mp.weixin.qq.com/s/g6m_r28bvyyWIu1CAzxLdg&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;计算机是怎样启动的？&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>x86-64-architecture</title>
      <link>http://localhost:1313/blog/x86-64-architecture/</link>
      <pubDate>Wed, 16 Oct 2019 13:59:24 +0800</pubDate>
      
      <guid>http://localhost:1313/blog/x86-64-architecture/</guid>
      <description>
        
        
        &lt;blockquote&gt;
  &lt;p&gt;操作系统其实很大一部分面向 &lt;code&gt;CPU&lt;/code&gt; 来编程的。一些 &lt;code&gt;OS&lt;/code&gt; 的概念直接来源于 &lt;code&gt;CPU&lt;/code&gt; 的术语，或者和 &lt;code&gt;CPU&lt;/code&gt; 关联性非常大。要想彻底理解 &lt;code&gt;OS&lt;/code&gt; ，无法绕过 &lt;code&gt;CPU&lt;/code&gt;。因为 Intel 的 &lt;code&gt;X86&lt;/code&gt;(Intel 80386 之后的一系列 CPU 称之为 X86 架构) 是业界的标准。掌握这个架构对于理解 &lt;code&gt;OS&lt;/code&gt; 是非常必要的。因为 &lt;code&gt;X86&lt;/code&gt; 系列的 &lt;code&gt;CPU&lt;/code&gt; 向后兼容，所以本文使用 Intel 8086(16 bit) 和 Intel 80386(32 bit) 来试图理解 &lt;code&gt;X86&lt;/code&gt; 架构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Intel 8086&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;intel-8086&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#intel-8086&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3&gt;16 bit processor&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;16-bit-processor&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#16-bit-processor&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;16-bit&lt;/code&gt; is a computer hardware device or software program capable of transferring 16 bits of data at a time. 一次传输 16 bits 的数据
For example, early computer processors (e.g., 8088 and 80286) were 16-bit processors, meaning they were capable of working with 16-bit binary numbers (decimal number up to 65,535). Anything larger and the computer would need to break the number into smaller pieces.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;1M 的寻址空间带来的问题与解决方法&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;1m-的寻址空间带来的问题与解决方法&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#1m-%e7%9a%84%e5%af%bb%e5%9d%80%e7%a9%ba%e9%97%b4%e5%b8%a6%e6%9d%a5%e7%9a%84%e9%97%ae%e9%a2%98%e4%b8%8e%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h4&gt;Intel 8086 地址引脚&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;intel-8086-地址引脚&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#intel-8086-%e5%9c%b0%e5%9d%80%e5%bc%95%e8%84%9a&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/stardustman/pictures/raw/main/img/intel8086_address.png&#34; alt=&#34;intel8086_address&#34; loading=&#34;lazy&#34; /&gt; #(Intel 8086 寻址空间)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;上图的 AD&lt;sub&gt;0&lt;/sub&gt; ~ AD&lt;sub&gt;15&lt;/sub&gt; 是复用(Multiplex)引脚
A&lt;sub&gt;16&lt;/sub&gt; ~ A&lt;sub&gt;19&lt;/sub&gt; 也是复用引脚&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;ALE(Address Latch Enable) = 1 是作为地址线 A&lt;sub&gt;0&lt;/sub&gt;~A&lt;sub&gt;15&lt;/sub&gt;(寻址) 再加上A&lt;sub&gt;16&lt;/sub&gt; ~ A&lt;sub&gt;19&lt;/sub&gt;.&lt;/li&gt;
&lt;li&gt;ALE(Address Latch Enable) = 0 是作为数据线 D&lt;sub&gt;0&lt;/sub&gt;~D&lt;sub&gt;15&lt;/sub&gt;(传输 16 bit 数据)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;物理地址生成&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;物理地址生成&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e7%89%a9%e7%90%86%e5%9c%b0%e5%9d%80%e7%94%9f%e6%88%90&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;blockquote&gt;
  &lt;p&gt;20 bit 来表示一个内存地址. 但是 Intel 8086 是一个 &lt;code&gt;16 bit&lt;/code&gt; 的处理器(其实就是一次只能传输 16 bit 的数据). 怎样来表示 &lt;code&gt;20 bit&lt;/code&gt; 的内存地址呢? 比如一个内存地址是: &lt;code&gt;0x18AC9&lt;/code&gt;, 该怎样表示呢? 其实道理很简单, 既然没法一次传输 20 bit, 那就分两次好了. 最后用两个 &lt;code&gt;16 bit&lt;/code&gt; 的数据来合成 &lt;code&gt;0x18AC9&lt;/code&gt; 这个地址. 很显然要有生成 &lt;code&gt;0x18AC9&lt;/code&gt; 这个地址的策略. 在 Intel 8086 中, 将 &lt;code&gt;0x18AC9&lt;/code&gt; 拆分为 &lt;code&gt;0x1234&lt;/code&gt;(segment address) 和 &lt;code&gt;0x6789&lt;/code&gt;(offset address) 这两个 &lt;code&gt;16 bit&lt;/code&gt; 的地址, 这就是所谓的逻辑地址(logical address). 怎样生成 &lt;code&gt;0x18AC9&lt;/code&gt; 这个真实的物理地址呢? 也很简单使用一个 &lt;code&gt;20 bit&lt;/code&gt; 的 &lt;code&gt;adder&lt;/code&gt;(加法器). 0x18AC9 = 0x1234 * 16 + 0x6789&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/stardustman/pictures/raw/main/img/intel8086_real_address_mode_translation.png&#34; alt=&#34;intel8086_real_address_mode_translation&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h4&gt;Real Address Mode&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;real-address-mode&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#real-address-mode&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;blockquote&gt;
  &lt;p&gt;物理地址由两部分组成: segment address 和 offset address. 这两个地址不能直接使用, 是用来合成真正的物理地址的. 这两个地址称之为 &lt;code&gt;逻辑地址&lt;/code&gt;. 16 * segment address + offset address 合成的地址称之为 &lt;code&gt;物理地址&lt;/code&gt;, 也叫 &lt;code&gt;线性地址&lt;/code&gt;(也就是从 0 ~ 2^20 -1 地址空间). Intel 8086 这种得到物理地址的机制就叫做 &lt;code&gt;real address mode&lt;/code&gt;. 也就是所谓的 &lt;code&gt;实模式&lt;/code&gt;.
PS: 多说一句, &lt;code&gt;实模式&lt;/code&gt; 这个翻译有点坑, 翻译成 &lt;code&gt;实地址模式&lt;/code&gt; 不就十分清楚了吗?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;segmented memory&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;segmented-memory&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#segmented-memory&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;blockquote&gt;
  &lt;p&gt;physical address = 16 * segment address + offset address
offset address 是 16 bit, 决定了一个 segment 的范围是 64K. 将 1M 的寻址空间以 64K 为一个 segment 划分为多个 segment. 反过来说就是一个 segment 可以选择一个 64K 范围内的地址. 是的, &lt;code&gt;segment&lt;/code&gt; 可以当作是一种 &lt;code&gt;selector&lt;/code&gt;, 就像 &lt;code&gt;CSS&lt;/code&gt; 里面的选择器.
那么这个 segment 存放在哪里呢? 放在专门的 &lt;code&gt;segment register&lt;/code&gt; 里.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;segment registers&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;segment-registers&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#segment-registers&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;blockquote&gt;
  &lt;p&gt;Intel 8086 提供了 &lt;code&gt;Extra Segment&lt;/code&gt;(ES), &lt;code&gt;Data Segment&lt;/code&gt;(DS), &lt;code&gt;Stack Segment&lt;/code&gt;(SS), &lt;code&gt;Code Segment&lt;/code&gt;(CS) 这 4 个 段寄存器.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5&gt;code segment(CS) + instruction pointer(IP)&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;code-segmentcs--instruction-pointerip&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#code-segmentcs--instruction-pointerip&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h5&gt;&lt;blockquote&gt;
  &lt;p&gt;code segment 存放 segment address, 这是个专门的代码段寄存器, 用来存放代码的地址.
instruction pointer 存放 offset address, 这个是专门的指令寄存器, 用来存放下一条指令的地址.
所以访问代码的 &lt;code&gt;物理地址 = 16 * CS + IP&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5&gt;stack segment(SS) + stack pointer(SP)&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;stack-segmentss--stack-pointersp&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#stack-segmentss--stack-pointersp&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h5&gt;&lt;blockquote&gt;
  &lt;p&gt;stack segment 存放 segment address, 这个是专门的栈帧段寄存器.
stack pointer 存放 offset address, 这个专门的记录栈顶的寄存器.
所以访问函数栈帧的 &lt;code&gt;物理地址 = 16 * SS + SP&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
  &lt;p&gt;注意: 如果令 SS = 0, 那么访问函数栈帧的 &lt;code&gt;物理地址 = SP&lt;/code&gt;, 也就是只能访问 64K 的空间.
注意: real address mode 能够不受限制地访问 1M 的地址空间. 程序可以自由的访问 1M 的地址空间, 无法进行内存的保护, 这也是 &lt;code&gt;Intel 80386&lt;/code&gt; 要解决的问题之一.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;h3&gt;general purpose register&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;general-purpose-register&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#general-purpose-register&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;memory mapping&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;memory-mapping&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#memory-mapping&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;blockquote&gt;
  &lt;p&gt;已安装内存 8G(7.88G) 可用？？？原因在哪里呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Intel 80386&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;intel-80386&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#intel-80386&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h2&gt;Reference&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;reference&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#reference&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://8086microprocessor4u.blogspot.com/2012/12/bus-interface-unit-biu.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bus interface unit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://8086microprocessor4u.blogspot.com/2015/04/the-execution-unit-eu.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;execution unit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/microprocessor/microprocessor_8086_functional_units.htm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;8086 Functional Units&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.csetutor.com/components-of-cpu-and-their-functions/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;components of cpu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://vdocuments.mx/8086-microprocessor-architecture-5584489b9c738.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;8086-microprocessor-architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.academia.edu/40314276/8086_microprocessor20190911_87442_nxpkcz&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;8086-microprocessor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/memory-segmentation-8086-microprocessor/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;memory-segmentation-8086-microprocessor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cs.usfca.edu/~cruse/cs630f06/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Advanced Microcomputer Programming&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.computerhope.com/jargon/num/16bit.htm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;16 bit processor mean?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cgnail.github.io/academic/mem-layout/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;memory layout&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cs.lmu.edu/~ray/notes/x86overview/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;x86-overview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/552957041/answer/2738625402&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;计算机位数发展&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

      </description>
    </item>
    
  </channel>
</rss>
